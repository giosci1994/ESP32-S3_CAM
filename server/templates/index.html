<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ESP32 Cam + MediaPipe + MQTT</title>
  <link rel="stylesheet" href="/static/style.css"/>
</head>
<body>
  <header>
    <h1>ESP32 Cam + MediaPipe (800x600 @ 25fps)</h1>
    <p>UI: <code>/</code> • Stream: <code>/stream</code> • Snapshot: <code>/snapshot.jpg</code> • Health: <code>/health</code></p>
    <button id="toggle-settings" class="settings-btn" type="button">⚙️ Settings</button>
  </header>
  <main>
    <section class="video">
      <img id="mjpeg" src="/stream" alt="stream"/>
    </section>
    <section class="panel">
      <div class="card"><div class="k">Gesture</div><div class="v" id="gesture">-</div></div>
      <div class="card"><div class="k">Confidence</div><div class="v" id="confidence">-</div></div>
      <div class="card"><div class="k">Hands</div><div class="v" id="hands">0</div></div>
      <div class="card"><div class="k">Pinch</div><div class="v" id="pinch">-</div></div>
    </section>
  </main>

  <div id="settings-overlay"></div>
  <aside id="settings-drawer">
    <section class="drawer-section">
      <header>
        <h2>Status</h2>
        <p>Controllo flusso video e connessione MQTT.</p>
      </header>
      <div class="status-list">
        <div class="status-item" id="status-video">
          <span class="label">Video stream</span>
          <span class="value">-</span>
        </div>
        <div class="status-item" id="status-mqtt">
          <span class="label">MQTT</span>
          <span class="value">-</span>
        </div>
        <div class="status-item" id="status-error">
          <span class="label">Ultimo errore</span>
          <span class="value">-</span>
        </div>
      </div>
      <div class="log-block" id="log-block">
        <div class="log-header">
          <span>Log (debug)</span>
          <button id="debug-toggle" type="button" class="pill-btn" data-state="off">Attiva debug</button>
        </div>
        <pre id="log-output">Debug non attivo</pre>
      </div>
    </section>

    <section class="drawer-section" id="gesture-section">
      <header>
        <div class="section-heading">
          <h2>Gesture MQTT</h2>
          <button id="gesture-collapse" type="button" class="collapse-btn" aria-expanded="true" aria-controls="gesture-content">Nascondi</button>
        </div>
        <p>Seleziona le gesture da inviare tramite MQTT e imposta la soglia minima di confidence.</p>
      </header>
      <div id="gesture-content" class="gesture-content">
        <div class="gesture-controls">
          <label for="confidence-threshold">Confidence minima</label>
          <div class="slider-row">
            <input id="confidence-threshold" type="range" min="0" max="100" step="1" value="70" />
            <span class="slider-value" id="confidence-threshold-value">70%</span>
          </div>
        </div>
        <div id="gesture-list" class="gesture-list"></div>
        <div class="gesture-actions">
          <button id="gesture-save" type="button">Salva selezione</button>
          <span class="gesture-status" id="gesture-status"></span>
        </div>
      </div>
    </section>
  </aside>

  <script>
    const gestureState = {
      available: [],
      active: new Set(),
      threshold: 0.7,
      dirty: false,
    };

    const gestureSection = document.getElementById('gesture-section');
    const gestureCollapseBtn = document.getElementById('gesture-collapse');
    const confidenceSlider = document.getElementById('confidence-threshold');
    const confidenceValueEl = document.getElementById('confidence-threshold-value');

    function clamp01(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) return 0;
      return Math.min(1, Math.max(0, value));
    }

    function setThresholdDisplay(value, syncSlider = true) {
      const pct = Math.round(clamp01(value) * 100);
      if (syncSlider && confidenceSlider) {
        confidenceSlider.value = String(pct);
      }
      if (confidenceValueEl) {
        confidenceValueEl.textContent = pct + '%';
      }
    }

    function updateGestureSaveState() {
      const btn = document.getElementById('gesture-save');
      if (!btn) return;
      btn.disabled = !gestureState.dirty;
    }

    function markGesturesDirty() {
      gestureState.dirty = true;
      updateGestureSaveState();
    }

    function setGestureSectionCollapsed(collapsed) {
      if (!gestureSection || !gestureCollapseBtn) return;
      gestureSection.classList.toggle('collapsed', collapsed);
      gestureCollapseBtn.setAttribute('aria-expanded', String(!collapsed));
      gestureCollapseBtn.textContent = collapsed ? 'Mostra' : 'Nascondi';
    }

    if (gestureCollapseBtn && gestureSection) {
      gestureCollapseBtn.addEventListener('click', () => {
        const collapsed = !gestureSection.classList.contains('collapsed');
        setGestureSectionCollapsed(collapsed);
      });
      setGestureSectionCollapsed(false);
    }

    if (confidenceSlider) {
      confidenceSlider.addEventListener('input', () => {
        const pct = parseInt(confidenceSlider.value, 10);
        if (Number.isNaN(pct)) return;
        gestureState.threshold = clamp01(pct / 100);
        setThresholdDisplay(gestureState.threshold, false);
        markGesturesDirty();
      });
    }

    const debugState = {
      enabled: false,
      locked: false,
      busy: false,
    };

    function toggleDrawer(forceState) {
      const isOpen = document.body.classList.contains('drawer-open');
      const next = forceState === undefined ? !isOpen : !!forceState;
      document.body.classList.toggle('drawer-open', next);
    }

    document.getElementById('toggle-settings').addEventListener('click', () => toggleDrawer());
    document.getElementById('settings-overlay').addEventListener('click', () => toggleDrawer(false));

    function setStatus(el, ok, text) {
      const valueEl = el.querySelector('.value');
      el.dataset.state = ok ? 'ok' : 'fail';
      valueEl.textContent = text;
    }

    function renderLogs(logs, debugEnabled) {
      const block = document.getElementById('log-block');
      const output = document.getElementById('log-output');
      block.dataset.active = debugEnabled ? 'on' : 'off';
      if (!debugEnabled) {
        output.textContent = 'Debug non attivo';
        return;
      }
      const lines = logs.slice(-120).map(entry => {
        const ts = new Date(entry.ts * 1000).toLocaleTimeString();
        return `[${ts}] ${entry.level}: ${entry.msg}`;
      });
      output.textContent = lines.join('\n') || 'Nessun log disponibile';
    }

    function renderGestures() {
      const container = document.getElementById('gesture-list');
      if (!container) return;
      setThresholdDisplay(gestureState.threshold);
      container.innerHTML = '';
      if (!gestureState.available.length) {
        const empty = document.createElement('div');
        empty.className = 'gesture-empty';
        empty.textContent = 'Nessuna gesture disponibile';
        container.appendChild(empty);
        updateGestureSaveState();
        return;
      }
      gestureState.available.forEach((name) => {
        const id = `gesture-${name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`;
        const wrapper = document.createElement('label');
        wrapper.className = 'gesture-item';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.value = name;
        input.checked = gestureState.active.has(name);
        input.id = id;
        input.addEventListener('change', () => {
          if (input.checked) {
            gestureState.active.add(name);
          } else {
            gestureState.active.delete(name);
          }
          markGesturesDirty();
        });
        const span = document.createElement('span');
        span.textContent = name;
        wrapper.appendChild(input);
        wrapper.appendChild(span);
        container.appendChild(wrapper);
      });
      updateGestureSaveState();
    }

    async function loadGestures() {
      try {
        const res = await fetch('/gestures');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        gestureState.available = data.available || [];
        gestureState.active = new Set(data.active || []);
        if (typeof data.confidence_threshold === 'number') {
          gestureState.threshold = clamp01(data.confidence_threshold);
        }
        gestureState.dirty = false;
        renderGestures();
      } catch (err) {
        document.getElementById('gesture-status').textContent = 'Errore caricamento gesture';
      }
    }

    async function saveGestures() {
      try {
        const res = await fetch('/gestures', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            active: Array.from(gestureState.active),
            confidence_threshold: gestureState.threshold,
          }),
        });
        const data = await res.json();
        if (!res.ok || data.ok === false) {
          throw new Error(data.error || 'Salvataggio fallito');
        }
        gestureState.active = new Set(data.active || []);
        if (typeof data.confidence_threshold === 'number') {
          gestureState.threshold = clamp01(data.confidence_threshold);
        }
        gestureState.dirty = false;
        renderGestures();
        document.getElementById('gesture-status').textContent = 'Salvato ✔';
        setTimeout(() => document.getElementById('gesture-status').textContent = '', 2000);
      } catch (err) {
        document.getElementById('gesture-status').textContent = 'Errore: ' + err.message;
      }
    }

    document.getElementById('gesture-save').addEventListener('click', saveGestures);
    updateGestureSaveState();

    function updateDebugButton() {
      const btn = document.getElementById('debug-toggle');
      if (!btn) return;
      btn.dataset.state = debugState.enabled ? 'on' : 'off';
      btn.textContent = debugState.enabled ? 'Disattiva debug' : 'Attiva debug';
      btn.disabled = debugState.busy || debugState.locked;
      btn.title = debugState.locked ? 'Debug forzato dalla configurazione' : '';
    }

    async function toggleDebug() {
      if (debugState.locked || debugState.busy) return;
      debugState.busy = true;
      updateDebugButton();
      try {
        const res = await fetch('/debug', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled: !debugState.enabled }),
        });
        const data = await res.json();
        if (!res.ok || data.ok === false) {
          throw new Error(data.error || 'Cambio debug fallito');
        }
        debugState.enabled = !!data.debug;
        debugState.locked = !!data.locked;
      } catch (err) {
        alert('Errore cambio debug: ' + err.message);
      } finally {
        debugState.busy = false;
        updateDebugButton();
      }
    }

    document.getElementById('debug-toggle').addEventListener('click', toggleDebug);

    async function refresh(){
      try{
        const r = await fetch('/status'); const j = await r.json();
        document.getElementById('gesture').textContent = j.gesture.label;
        document.getElementById('confidence').textContent = (j.gesture.confidence||0).toFixed(2);
        document.getElementById('hands').textContent = j.gesture.num_hands||0;
        document.getElementById('pinch').textContent = j.pinch.distance_px.toFixed(1) + 'px ' + j.pinch.trend;

        const videoText = j.video.ok ? 'Online' : 'Offline';
        setStatus(document.getElementById('status-video'), j.video.ok, videoText);
        const mqttText = j.mqtt.connected ? `Connesso (${j.mqtt.host}:${j.mqtt.port})` : 'Disconnesso';
        setStatus(document.getElementById('status-mqtt'), j.mqtt.connected, mqttText);
        const errorText = j.last_error || j.mqtt.last_error || 'Nessun errore';
        setStatus(document.getElementById('status-error'), !errorText || errorText === 'Nessun errore', errorText);

        debugState.enabled = !!j.debug;
        debugState.locked = !!j.debug_locked;
        updateDebugButton();

        renderLogs(j.logs || [], debugState.enabled);

        if (!gestureState.dirty && (j.active_gestures || []).length && gestureState.available.length) {
          gestureState.active = new Set(j.active_gestures);
          renderGestures();
        }
        if (!gestureState.dirty && typeof j.confidence_threshold === 'number') {
          gestureState.threshold = clamp01(j.confidence_threshold);
          setThresholdDisplay(gestureState.threshold);
          updateGestureSaveState();
        }
      }catch(e){
        console.error('Refresh error', e);
      }
    }

    loadGestures();
    setInterval(refresh, 1200); refresh();
  </script>
</body>
</html>
